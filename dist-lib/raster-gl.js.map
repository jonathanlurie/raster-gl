{"version":3,"file":"raster-gl.js","names":["textureUnitSlots: Array<boolean>","defaultOptionValues: TextureOptions","u: UniformData"],"sources":["../src/lib/gltools.ts","../src/lib/shaders/default.fs.glsl?raw","../src/lib/shaders/default.vs.glsl?raw","../src/lib/Texture.ts","../src/lib/typetester.ts","../src/lib/ProcessingNode.ts","../src/lib/RasterContext.ts"],"sourcesContent":["export const DEFAULT_WIDTH = 512;\nexport const DEFAULT_HEIGHT = 512;\nlet currentTextureUnit = 0;\n\n// Keeps track of what texture unit is already in use\nconst textureUnitSlots: Array<boolean> = Array(16).fill(false);\n\nexport function getUnusedTextureUnit(): number {\n  for (let i = 0; i < textureUnitSlots.length; i += 1) {\n    if (!textureUnitSlots[i]) {\n      textureUnitSlots[i] = true;\n      return i;\n    }\n  }\n\n  throw new Error(\"All the texture units are already allocated.\");\n}\n\nexport function freeTextureUnit(i: number) {\n  textureUnitSlots[i] = false;\n}\n\nexport function getCurrentTextureUnit(): number {\n  return currentTextureUnit;\n}\n\nexport function incrementCurrentTextureUnit() {\n  currentTextureUnit++;\n}\n\n// From Fragment.ink\nexport function getShaderCompileError(\n  gl: WebGL2RenderingContext,\n  vertexShaderSource: string,\n  fragmentShaderSource: string,\n) {\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER) as WebGLShader;\n  gl.shaderSource(vertexShader, vertexShaderSource);\n  gl.compileShader(vertexShader);\n  const vertexShaderMessages = gl.getShaderInfoLog(vertexShader);\n\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER) as WebGLShader;\n  gl.shaderSource(fragmentShader, fragmentShaderSource);\n  gl.compileShader(fragmentShader);\n  const fragmentShaderMessages = gl.getShaderInfoLog(fragmentShader);\n\n  return {\n    vertexShaderMessages,\n    fragmentShaderMessages,\n  };\n}\n\nexport function createProgram(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): { program: WebGLProgram | null; error: string | null } {\n  const program = gl.createProgram() as WebGLProgram;\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    // console.error('Program linking error:', gl.getProgramInfoLog(program));\n    const error = gl.getProgramInfoLog(program);\n    gl.deleteProgram(program);\n    return { program: null, error };\n  }\n\n  return { program, error: null };\n}\n\nexport function compileShader(\n  gl: WebGL2RenderingContext,\n  type: number,\n  source: string,\n): { shader: WebGLShader | null; error: string | null } {\n  const shader = gl.createShader(type) as WebGLShader;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const error = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    return { shader: null, error };\n  }\n\n  return { shader, error: null };\n}\n\nexport function prepareGlContext(options: {\n  canvasElemId?: string;\n  width: number;\n  height: number;\n}): WebGL2RenderingContext {\n  const canvas = (\n    options.canvasElemId ? document.getElementById(options.canvasElemId) : document.createElement(\"canvas\")\n  ) as HTMLCanvasElement;\n  canvas.width = options.width;\n  canvas.height = options.height;\n  const gl = canvas.getContext(\"webgl2\") as WebGL2RenderingContext;\n\n  if (!gl) {\n    throw new Error(\"WebGL2 not supported in this browser.\");\n  }\n\n  return gl;\n}\n\n// export function uniformToGlFunction(value: ): string {\n\n// }\n","export default \"#version 300 es\\nprecision highp float;\\n\\nin vec2 uv;\\nout vec4 fragColor;\\n\\nvoid main() {\\n  fragColor = vec4(uv.x, uv.y, 1. - uv.x * uv.y, 1.);\\n}\"","export default \"#version 300 es\\nprecision highp float;\\n\\nin vec2 a_position;\\nout vec4 position;\\nout vec2 uv;\\n\\nvoid main() {\\n  position = vec4(a_position, 0.0, 1.0);\\n  gl_Position = position;\\n  uv = position.xy / 2. + 0.5;\\n}\"","import { freeTextureUnit, getUnusedTextureUnit } from \"./gltools\";\nimport type { ProcessingNode } from \"./ProcessingNode\";\nimport type { RasterContext } from \"./RasterContext\";\n\nexport type TextureOptions = {\n  /**\n   * WebGL begin oriented from bottom to top, flipping the texture vertically\n   * will have the effect of showing it from its natural orientation.\n   * Default: `true`\n   */\n  verticalFlip?: boolean;\n\n  /**\n   * Interpolation of the texture. Bilinear will interpolated the color values in-between the pixel.\n   * If not bilinear, then the nearest neighboor pixel lookup will be performed.\n   * Default: `true`\n   */\n  bilinear?: boolean;\n};\n\nexport type UsageRecord = {\n  node: ProcessingNode;\n  uniformName: string;\n};\n\nconst defaultOptionValues: TextureOptions = {\n  verticalFlip: true,\n  bilinear: true,\n};\n\nexport async function fetchAsImageBitmap(url: string, abortSignal?: AbortSignal): Promise<ImageBitmap> {\n  const response = await fetch(url, { signal: abortSignal });\n  if (!response.ok) {\n    throw new Error(`Fetch failed: ${response.status}`);\n  }\n\n  const blob = await response.blob();\n  const imageBitmap = await createImageBitmap(blob);\n  return imageBitmap;\n}\n\nexport class Texture {\n  public readonly width: number;\n  public readonly height: number;\n  public readonly bitDepth: number;\n  private _textureUnit: number | null = null;\n  private _texture: WebGLTexture | null = null;\n  private readonly usageRecords: Array<UsageRecord> = [];\n  private readonly rasterContext: RasterContext;\n\n  // TODO: fromFile (with a file picker)\n\n  /**\n   * Instanciate a Texture from an ImageBitmap\n   */\n  static fromImageSource(rasterContext: RasterContext, image: TexImageSource, options: TextureOptions = {}): Texture {\n    const gl = rasterContext.getGlContext();\n\n    const optionsWithDefault = {\n      ...defaultOptionValues,\n      ...options,\n    };\n    const interpolation = optionsWithDefault.bilinear ? gl.LINEAR : gl.NEAREST;\n\n    const texture = gl.createTexture();\n\n    if (optionsWithDefault.verticalFlip) {\n      // Make sure the texture is loaded as flipped to not be upside down\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    // Upload the image data to the texture\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\n    // Set texture parameters (you can adjust these as needed)\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, interpolation);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, interpolation);\n\n    // TODO: unbind texture?\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    if (!texture) {\n      throw new Error(\"Could not load image\");\n    }\n\n    let width = 0;\n    let height = 0;\n\n    if (image instanceof VideoFrame) {\n      width = image.codedWidth;\n      height = image.codedHeight;\n    } else {\n      width = image.width;\n      height = image.height;\n    }\n\n    if (width === 0 || height === 0) {\n      throw new Error(`Image dimensions are invalid (${width}, ${height})`);\n    }\n\n    return new Texture(rasterContext, texture, width, height, 8);\n  }\n\n  /**\n   * Create a Texture instance from the URL of an image (png or jpeg)\n   */\n  static async fromURL(rasterContext: RasterContext, url: string, options: TextureOptions = {}): Promise<Texture> {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Fetch failed: ${response.status}`);\n    }\n\n    const blob = await response.blob();\n    const imageBitmap = await createImageBitmap(blob);\n    return Texture.fromImageSource(rasterContext, imageBitmap, options);\n  }\n\n  static fromData(\n    rasterContext: RasterContext,\n    data: Uint8Array,\n    width: number,\n    height: number,\n    options: TextureOptions = {},\n  ): Texture {\n    const gl = rasterContext.getGlContext();\n    const texture = gl.createTexture();\n\n    const optionsWithDefault = {\n      ...defaultOptionValues,\n      ...options,\n    };\n    const interpolation = optionsWithDefault.bilinear ? gl.LINEAR : gl.NEAREST;\n\n    if (!texture) throw new Error(\"The texture could not be initialized\");\n\n    if (optionsWithDefault.verticalFlip) {\n      // Make sure the texture is loaded as flipped to not be upside down\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    const numberOfElementPerPixel = data.length / (width * height);\n\n    if (numberOfElementPerPixel === 3) {\n      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, data);\n    } else if (numberOfElementPerPixel === 4) {\n      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n    } else {\n      throw new Error(\n        \"Invalid number of elements per pixel. The data texture must contain 1, 3 or 4 elements per pixel.\",\n      );\n    }\n\n    // Set texture parameters (you can adjust these as needed)\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, interpolation);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, interpolation);\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    return new Texture(rasterContext, texture, width, height, data.BYTES_PER_ELEMENT * 8);\n  }\n\n  constructor(rasterContext: RasterContext, texture: WebGLTexture, width: number, height: number, bitDepth: number) {\n    this._texture = texture;\n    this.width = width;\n    this.height = height;\n    this.bitDepth = bitDepth;\n    this.rasterContext = rasterContext;\n    this.rasterContext.registerTexture(this);\n  }\n\n  get textureUnit(): number {\n    this._textureUnit ??= getUnusedTextureUnit();\n\n    return this._textureUnit;\n  }\n\n  get texture(): WebGLTexture {\n    if (!this._texture) {\n      throw new Error(\"This texture is not complete or has been disposed.\");\n    }\n    return this._texture;\n  }\n\n  /**\n   * Dissociates from its texture unit (if previopusly associated)\n   */\n  rest() {\n    if (this._textureUnit !== null) {\n      freeTextureUnit(this._textureUnit);\n      this._textureUnit = null;\n    }\n  }\n\n  /**\n   * Frees the GPU memory for this texture.\n   * After this, the texture is no longer usable.\n   */\n  free() {\n    if (!this._texture) {\n      return;\n    }\n\n    const gl = this.rasterContext.getGlContext();\n\n    // Unbind if this texture is currently bound in this context.\n    // WebGL will generally handle delete + existing bindings gracefully, but\n    // unbinding avoids \"use-after-free\" patterns\n    const isBound = gl.getParameter(gl.TEXTURE_BINDING_2D) === this._texture;\n\n    if (isBound) {\n      gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    gl.deleteTexture(this._texture);\n    this._texture = null;\n\n    // Release the (client-side) texture unit bookkeeping.\n    this.rest();\n  }\n\n  private getIndexUsageRecord(node: ProcessingNode, uniformName: string): number {\n    for (let i = 0; i < this.usageRecords.length; i += 1) {\n      if (this.usageRecords[i].node === node && this.usageRecords[i].uniformName === uniformName) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Adds a usage record corresponding to a node + uniform\n   */\n  addUsageRecord(node: ProcessingNode, uniformName: string) {\n    const indexExisting = this.getIndexUsageRecord(node, uniformName);\n    if (indexExisting >= 0) return;\n    this.usageRecords.push({ node, uniformName });\n  }\n\n  /**\n   * Removes a usage record corresponding to a node + uniform.\n   * Puts the texture unit at rest if this texture is no longer in use by\n   * any node.\n   */\n  removeUsageRecord(node: ProcessingNode, uniformName: string) {\n    const indexExisting = this.getIndexUsageRecord(node, uniformName);\n    if (indexExisting === -1) return;\n    this.usageRecords.splice(indexExisting, 1);\n\n    if (this.usageRecords.length === 0) {\n      this.rest();\n    }\n  }\n}\n","import { Texture } from \"./Texture\";\n\nexport type Vec2 = [number, number];\nexport type Vec3 = [number, number, number];\nexport type Vec4 = [number, number, number, number];\n\n// Diffent types of numerical uniforms\nexport enum UNIFORM_TYPE {\n  /**\n   * Boolean\n   */\n  BOOL = 1,\n\n  /**\n   * Signed integer\n   */\n  INT = 3,\n\n  /**\n   * Float\n   */\n  FLOAT = 4,\n}\n\nexport function isObject(value: unknown): boolean {\n  return typeof value === \"object\" && !Array.isArray(value) && value !== null;\n}\n\nexport function isBoolean(value: unknown): boolean {\n  return typeof value === \"boolean\";\n}\n\nexport function isNumber(value: unknown): boolean {\n  return typeof value === \"number\";\n}\n\nexport function isArrayOfNumber(value: unknown): boolean {\n  if (!Array.isArray(value)) return false;\n  return value.every((el) => isNumber(el));\n}\n\nexport function isTexture(value: unknown): boolean {\n  return value instanceof Texture;\n}\n\nexport function isArrayOfTexture(value: unknown): boolean {\n  if (!Array.isArray(value)) return false;\n  return value.every((el) => isTexture(el));\n}\n\nexport function isVector2(value: unknown): boolean {\n  return Array.isArray(value) && isArrayOfNumber(value) && value.length === 2;\n}\n\nexport function isVector3(value: unknown): boolean {\n  return Array.isArray(value) && isArrayOfNumber(value) && value.length === 3;\n}\n\nexport function isVector4(value: unknown): boolean {\n  return Array.isArray(value) && isArrayOfNumber(value) && value.length === 5;\n}\n\nexport function isMatrix2(value: unknown): boolean {\n  return Array.isArray(value) && isArrayOfNumber(value) && value.length === 4;\n}\n\nexport function isMatrix3(value: unknown): boolean {\n  return Array.isArray(value) && isArrayOfNumber(value) && value.length === 9;\n}\n\nexport function isMatrix4(value: unknown): boolean {\n  return Array.isArray(value) && isArrayOfNumber(value) && value.length === 16;\n}\n","// Note: if target canvas is resized: https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n\nimport { compileShader, createProgram } from \"./gltools\";\nimport type { RasterContext } from \"./RasterContext\";\nimport defaultFragmentShader from \"./shaders/default.fs.glsl?raw\";\nimport defaultVertexShader from \"./shaders/default.vs.glsl?raw\";\nimport { Texture } from \"./Texture\";\nimport { isArrayOfTexture, isTexture, UNIFORM_TYPE, type Vec2, type Vec3, type Vec4 } from \"./typetester\";\n\n// Many uniform functions exist and they have different signature depending on type\n// but this kind of covers all the usages\ntype UniformFunction = (location: WebGLUniformLocation | null, ...args: any[]) => void;\n\ntype UniformData = {\n  /**\n   * Name of the uniform as used from within the shader code (eg. \"u_myNumber\")\n   */\n  name: string;\n\n  /**\n   * Track whether or not the uniform was updated and its value needs to be pushed to GPU\n   */\n  needsUpdate: boolean;\n\n  /**\n   * The value of the uniform\n   */\n  // value: boolean | number | vec2 | vec3 | vec4, // TODO add sampler and matrices\n\n  /**\n   * Memory location. Is `null` if not allocated yet.\n   */\n  location: WebGLUniformLocation | null;\n\n  /**\n   * If the value is a number, its particular type could be forced to uint, int or float\n   */\n  forcedType?: UNIFORM_TYPE;\n\n  /**\n   * Function to use on the gl context to update this uniform (eg. `gl.uniform1f`)\n   */\n  uniformFunction: UniformFunction | null;\n\n  /**\n   * Array of arguments to pass to `uniformFunction`\n   */\n  uniformFunctionArguments: number[] | number[][] | Texture[] | Texture[][] | null;\n\n  /**\n   * Tells if this uniform is a texture\n   */\n  isTexture?: boolean;\n\n  fragmentTexture?: Texture;\n};\n\n/**\n * Color channels: R, G, B and A with values in [0, 1]\n */\nexport type RGBAUnitColor = [number, number, number, number];\n\nexport class ProcessingNode {\n  private readonly rasterContext: RasterContext;\n  private renderToTexture: boolean;\n  private readonly reuseOutputTexture: boolean;\n  private outputWidth: number;\n  private outputHeight: number;\n  private outputNeedUpdate = true;\n  private positionAttributeLocation: number | null = null;\n  private compiledVertexShader: WebGLShader | null = null;\n  private compiledFragmentShader: WebGLShader | null = null;\n  private vertexShaderError: string | null = null;\n  private fragmentShaderError: string | null = null;\n  private shaderProgram: WebGLProgram | null = null;\n  private shaderProgramError: string | null = null;\n  private uniforms: { [key: string]: UniformData } = {};\n  private clearColor: RGBAUnitColor = [0, 0, 0, 1];\n  private outputTexture: Texture | null = null;\n  private framebuffer: WebGLFramebuffer | null = null;\n  private positionBuffer: WebGLBuffer | null = null;\n  // private isOffscreen: boolean;\n  private readonly uint32: boolean = false;\n\n  constructor(\n    rasterContext: RasterContext,\n    options: {\n      renderToTexture?: boolean;\n\n      /**\n       * When true, the same output texture is reused for every render call (convenient for multipass animation)\n       * When false, a new texture is created for each render call (convenient to reuse the same node to create different outputs)\n       * Used only if renderToTexture is true.\n       */\n      reuseOutputTexture?: boolean;\n      width?: number;\n      height?: number;\n      uint32?: boolean;\n\n      /**\n       * The clear color is of form RGBA where each channel is a value in [0, 1].\n       * Default: [0, 0, 0, 1]\n       */\n      clearColor?: [number, number, number, number];\n    } = {},\n  ) {\n    this.rasterContext = rasterContext;\n    const ctxSize = this.rasterContext.getSize();\n    this.renderToTexture = options.renderToTexture ?? false;\n    this.reuseOutputTexture = options.reuseOutputTexture ?? true;\n    this.outputWidth = options.width ?? ctxSize.width;\n    this.outputHeight = options.height ?? ctxSize.height;\n    this.uint32 = options.uint32 ?? false;\n    const gl = this.rasterContext.getGlContext();\n\n    // Regardless of the render target, the canvas size must be adapted\n    if (this.renderToTexture) {\n      gl.canvas.width = this.outputWidth;\n      gl.canvas.height = this.outputHeight;\n    } else {\n      if (this.uint32) {\n        throw new Error(\"A Node can only output uint32 when rendering to texture.\");\n      }\n\n      // Particularity for hi-DPI screens\n      gl.canvas.width = this.outputWidth * devicePixelRatio;\n      gl.canvas.height = this.outputHeight * devicePixelRatio;\n\n      if (!(gl.canvas instanceof OffscreenCanvas)) {\n        gl.canvas.style.width = `${this.outputWidth}px`;\n        gl.canvas.style.height = `${this.outputHeight}px`;\n      }\n    }\n  }\n\n  setClearColor(color: RGBAUnitColor) {\n    this.clearColor[0] = color[0];\n    this.clearColor[1] = color[1];\n    this.clearColor[2] = color[2];\n    this.clearColor[3] = color[3];\n  }\n\n  setOutputSize(w: number, h: number) {\n    this.outputWidth = w;\n    this.outputHeight = h;\n    this.outputNeedUpdate = true;\n  }\n\n  setRenderToTexture(b: boolean) {\n    this.renderToTexture = b;\n    this.outputNeedUpdate = true;\n  }\n\n  getVertexShaderError(): string | null {\n    return this.vertexShaderError;\n  }\n\n  getFragmentShaderError(): string | null {\n    return this.fragmentShaderError;\n  }\n\n  getProgramError(): string | null {\n    return this.shaderProgramError;\n  }\n\n  private resetProgram() {\n    const gl = this.rasterContext.getGlContext();\n    gl.deleteProgram(this.shaderProgram);\n    this.shaderProgram = null;\n    this.shaderProgramError = null;\n\n    gl.deleteShader(this.compiledVertexShader);\n    this.compiledVertexShader = null;\n    this.vertexShaderError = null;\n\n    gl.deleteShader(this.compiledFragmentShader);\n    this.compiledFragmentShader = null;\n    this.fragmentShaderError = null;\n  }\n\n  setShaderSource(options: { vertexShaderSource?: string; fragmentShaderSource?: string; throw?: boolean } = {}) {\n    this.resetProgram();\n\n    const shouldThrow = options.throw ?? true;\n    const vertexShaderSource = options.vertexShaderSource ?? defaultVertexShader;\n    const fragmentShaderSource = options.fragmentShaderSource ?? defaultFragmentShader;\n\n    const gl = this.rasterContext.getGlContext();\n    const vertexShaderData = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShaderData = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    this.compiledVertexShader = vertexShaderData.shader;\n    this.compiledFragmentShader = fragmentShaderData.shader;\n    this.vertexShaderError = vertexShaderData.error;\n    this.fragmentShaderError = fragmentShaderData.error;\n\n    if (shouldThrow && (vertexShaderData.error || fragmentShaderData.error)) {\n      if (vertexShaderData.error) {\n        throw new Error(vertexShaderData.error);\n      }\n      if (fragmentShaderData.error) {\n        throw new Error(fragmentShaderData.error);\n      }\n    }\n\n    if (vertexShaderData.shader === null || fragmentShaderData.shader === null) return;\n\n    const programData = createProgram(gl, vertexShaderData.shader, fragmentShaderData.shader);\n    this.shaderProgram = programData.program;\n    this.shaderProgramError = programData.error;\n\n    if (shouldThrow && programData.error) {\n      throw new Error(programData.error);\n    }\n\n    gl.useProgram(this.shaderProgram);\n  }\n\n  isProgramValid(): boolean {\n    return !!this.shaderProgram;\n  }\n\n  /**\n   * Add a boolean or an array of boolean a uniform.\n   * The type is float by default but can be enforce to a integer\n   */\n  setUniformBoolean(name: string, value: boolean | boolean[]) {\n    this.outputNeedUpdate = true;\n    const gl = this.rasterContext.getGlContext();\n    let u: UniformData;\n\n    if (name in this.uniforms) {\n      u = this.uniforms[name];\n      u.needsUpdate = true;\n    } else {\n      u = {\n        name,\n        needsUpdate: true,\n        location: null,\n        forcedType: UNIFORM_TYPE.BOOL,\n        uniformFunction: null,\n        uniformFunctionArguments: null,\n      };\n    }\n\n    // If unique boolean, do like a int\n    if (typeof value === \"boolean\") {\n      u.uniformFunction = gl.uniform1i;\n      u.uniformFunctionArguments = [+value];\n      this.uniforms[name] = u;\n    }\n\n    // If Array of booleans, do like ints\n    else if (Array.isArray(value) && value.length > 0 && typeof value[0] === \"boolean\") {\n      u.uniformFunction = gl.uniform1iv;\n      u.uniformFunctionArguments = [value.map((el: boolean) => +el)];\n      this.uniforms[name] = u;\n    } else {\n      console.warn(`Uniform ${name} type mismatch`);\n    }\n  }\n\n  /**\n   * Add a number or an array of numbers a uniform.\n   * The type is float by default but can be enforce to a integer\n   */\n  setUniformNumber(name: string, value: number | number[], type: UNIFORM_TYPE = UNIFORM_TYPE.FLOAT) {\n    this.outputNeedUpdate = true;\n    const gl = this.rasterContext.getGlContext();\n    let u: UniformData;\n\n    if (name in this.uniforms) {\n      u = this.uniforms[name];\n      u.needsUpdate = true;\n    } else {\n      u = {\n        name,\n        needsUpdate: true,\n        location: null,\n        forcedType: type,\n        uniformFunction: null,\n        uniformFunctionArguments: null,\n      };\n    }\n\n    // If unique float\n    if (typeof value === \"number\" && type === UNIFORM_TYPE.FLOAT) {\n      u.uniformFunction = gl.uniform1f;\n      u.uniformFunctionArguments = [value];\n      this.uniforms[name] = u;\n    }\n\n    // If unique int\n    else if (typeof value === \"number\" && type === UNIFORM_TYPE.INT) {\n      u.uniformFunction = gl.uniform1i;\n      u.uniformFunctionArguments = [value];\n      this.uniforms[name] = u;\n    }\n\n    // If Array of float\n    else if (Array.isArray(value) && value.length > 0 && typeof value[0] === \"number\" && type === UNIFORM_TYPE.FLOAT) {\n      u.uniformFunction = gl.uniform1fv;\n      u.uniformFunctionArguments = [value];\n      this.uniforms[name] = u;\n    }\n\n    // If Array of int\n    else if (Array.isArray(value) && value.length > 0 && typeof value[0] === \"number\" && type === UNIFORM_TYPE.INT) {\n      u.uniformFunction = gl.uniform1iv;\n      u.uniformFunctionArguments = [value];\n      this.uniforms[name] = u;\n    } else {\n      console.warn(`Uniform ${name} type mismatch`);\n    }\n  }\n\n  /**\n   * Add a texture as uniform\n   */\n  setUniformTexture2D(name: string, value: Texture | ProcessingNode /* | Texture[]*/) {\n    this.outputNeedUpdate = true;\n    let u: UniformData;\n    const gl = this.rasterContext.getGlContext();\n\n    if (name in this.uniforms) {\n      u = this.uniforms[name];\n      u.needsUpdate = true;\n      u.fragmentTexture?.removeUsageRecord(this, name);\n    } else {\n      u = {\n        name,\n        needsUpdate: true,\n        location: null,\n        uniformFunction: null,\n        uniformFunctionArguments: null,\n        isTexture: true,\n      };\n    }\n\n    // A ProcessingNode instance, from which we get the output texture\n    if (value instanceof ProcessingNode) {\n      const texture = value.getOutputTexture();\n      u.uniformFunction = gl.uniform1i;\n      u.fragmentTexture = texture;\n      u.fragmentTexture?.addUsageRecord(this, name);\n      u.uniformFunctionArguments = [u.fragmentTexture.textureUnit];\n      this.uniforms[name] = u;\n    }\n\n    // A texture\n    else if (isTexture(value)) {\n      u.uniformFunction = gl.uniform1i;\n      u.fragmentTexture = value;\n      u.fragmentTexture?.addUsageRecord(this, name);\n      u.uniformFunctionArguments = [u.fragmentTexture.textureUnit];\n      this.uniforms[name] = u;\n    }\n\n    // An array of texture\n    else if (isArrayOfTexture(value)) {\n      // u.uniformFunction = this.gl.uniform1iv;\n      // u.uniformFunctionArguments = [value];\n      // this.uniforms[name] = u;\n      console.warn(\"Fragment does not support arrays of textures yet.\");\n    } else {\n      console.warn(`Uniform ${name} type mismatch`);\n    }\n  }\n\n  setUniformVector2(name: string, value: Vec2 /*| Array<Vec2>*/, type: UNIFORM_TYPE = UNIFORM_TYPE.FLOAT) {\n    this.outputNeedUpdate = true;\n    const gl = this.rasterContext.getGlContext();\n    let u: UniformData;\n\n    if (name in this.uniforms) {\n      u = this.uniforms[name];\n      u.needsUpdate = true;\n    } else {\n      u = {\n        name,\n        needsUpdate: true,\n        location: null,\n        forcedType: type,\n        uniformFunction: null,\n        uniformFunctionArguments: null,\n      };\n    }\n\n    // If Vec2 of floats\n    if (type === UNIFORM_TYPE.FLOAT) {\n      u.uniformFunction = gl.uniform2f;\n      u.uniformFunctionArguments = [value[0], value[1]];\n      this.uniforms[name] = u;\n    }\n\n    // If Vec2 of ints\n    else if (type === UNIFORM_TYPE.INT) {\n      u.uniformFunction = gl.uniform2i;\n      u.uniformFunctionArguments = [value[0], value[1]];\n      this.uniforms[name] = u;\n    } else {\n      console.warn(`Uniform ${name} type mismatch`);\n    }\n  }\n\n  setUniformVector3(name: string, value: Vec3 /*| Array<vec3>*/, type: UNIFORM_TYPE = UNIFORM_TYPE.FLOAT) {\n    this.outputNeedUpdate = true;\n    const gl = this.rasterContext.getGlContext();\n    let u: UniformData;\n\n    if (name in this.uniforms) {\n      u = this.uniforms[name];\n      u.needsUpdate = true;\n    } else {\n      u = {\n        name,\n        needsUpdate: true,\n        location: null,\n        forcedType: type,\n        uniformFunction: null,\n        uniformFunctionArguments: null,\n      };\n    }\n\n    // If Vec2 of floats\n    if (type === UNIFORM_TYPE.FLOAT) {\n      u.uniformFunction = gl.uniform3f;\n      u.uniformFunctionArguments = [value[0], value[1], value[2]];\n      this.uniforms[name] = u;\n    }\n\n    // If Vec2 of ints\n    else if (type === UNIFORM_TYPE.INT) {\n      u.uniformFunction = gl.uniform3i;\n      u.uniformFunctionArguments = [value[0], value[1], value[2]];\n      this.uniforms[name] = u;\n    } else {\n      console.warn(`Uniform ${name} type mismatch`);\n    }\n  }\n\n  setUniformVector4(name: string, value: Vec4 /*| Array<vec4>*/, type: UNIFORM_TYPE = UNIFORM_TYPE.FLOAT) {\n    this.outputNeedUpdate = true;\n    const gl = this.rasterContext.getGlContext();\n    let u: UniformData;\n\n    if (name in this.uniforms) {\n      u = this.uniforms[name];\n      u.needsUpdate = true;\n    } else {\n      u = {\n        name,\n        needsUpdate: true,\n        location: null,\n        forcedType: type,\n        uniformFunction: null,\n        uniformFunctionArguments: null,\n      };\n    }\n\n    // If Vec2 of floats\n    if (type === UNIFORM_TYPE.FLOAT) {\n      u.uniformFunction = gl.uniform4f;\n      u.uniformFunctionArguments = [value[0], value[1], value[2], value[3]];\n      this.uniforms[name] = u;\n    }\n\n    // If Vec2 of ints\n    else if (type === UNIFORM_TYPE.INT) {\n      u.uniformFunction = gl.uniform4i;\n      u.uniformFunctionArguments = [value[0], value[1], value[2], value[3]];\n      this.uniforms[name] = u;\n    } else {\n      console.warn(`Uniform ${name} type mismatch`);\n    }\n  }\n\n  /**\n   * Set a RGB color as uniform, where each color channel is in [0, 255]\n   */\n  setUniformRGB(name: string, value: Vec3) {\n    this.setUniformVector3(name, [value[0] / 255, value[1] / 255, value[2] / 255]);\n  }\n\n  /**\n   * Set a RGB color as uniform, where each color channel (RGB) is in [0, 255]\n   * and transparency is in [0, 1]\n   */\n  setUniformRGBA(name: string, value: Vec4) {\n    this.setUniformVector4(name, [value[0] / 255, value[1] / 255, value[2] / 255, value[3]]);\n  }\n\n  private initUniforms() {\n    const gl = this.rasterContext.getGlContext();\n    const program = this.shaderProgram;\n\n    if (!program) {\n      return;\n    }\n\n    const uniformArray = Object.keys(this.uniforms).map((k: string) => this.uniforms[k]);\n    const textureUniforms = uniformArray.filter((u) => u.isTexture);\n    const nonTextureUniforms = uniformArray.filter((u) => !u.isTexture);\n\n    for (const u of nonTextureUniforms) {\n      if (!u.needsUpdate) return;\n      if (!u.uniformFunction) return;\n      if (!u.uniformFunctionArguments) return;\n\n      // If it's the first use of this uniform, we have to find a location for it\n      u.location ??= gl.getUniformLocation(program, u.name);\n\n      // Set the value\n      u.uniformFunction.apply(gl, [u.location, ...u.uniformFunctionArguments]);\n\n      u.needsUpdate = false;\n    }\n\n    // The case of texture uniforms is handled separately.\n    // More info: See: https://webglfundamentals.org/webgl/lessons/webgl-2-textures.html\n    for (const u of textureUniforms) {\n      if (!u.needsUpdate) return;\n      if (!u.uniformFunction) return;\n      if (!u.uniformFunctionArguments) return;\n      if (!u.fragmentTexture) return;\n\n      // If it's the first use of this uniform, we have to find a location for it\n      u.location ??= gl.getUniformLocation(program, u.name);\n\n      const textureUnit = u.fragmentTexture.textureUnit;\n\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n      gl.bindTexture(gl.TEXTURE_2D, u.fragmentTexture.texture);\n\n      // Set the value\n      u.uniformFunction.apply(gl, [u.location, textureUnit]);\n\n      u.needsUpdate = false;\n    }\n  }\n\n  private initPlane() {\n    const gl = this.rasterContext.getGlContext();\n    if (this.positionAttributeLocation) return;\n\n    const program = this.shaderProgram;\n\n    if (!program) return;\n    // gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n    this.positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n\n    this.positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n\n    // Define the vertices of the rectangle\n    const vertices = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0];\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(this.positionAttributeLocation);\n    gl.vertexAttribPointer(this.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n  }\n\n  /**\n   * Get the output texture.\n   * Will be `null` if this node was set to render to a canvas.\n   * Will be a valid `FragmentTexture` if this node was set to render to texture.\n   */\n  getOutputTexture(): Texture {\n    // Force a rendering if necessary\n    if (this.outputNeedUpdate) {\n      this.render();\n    }\n\n    if (!this.outputTexture) {\n      console.warn(\"[GPU readback necessary] This node is not rendering to a texture.\");\n      return Texture.fromImageSource(this.rasterContext, this.getNewOffscreenCanvas());\n    }\n\n    return this.outputTexture;\n  }\n\n  private initRenderToTextureLogic() {\n    if (!this.renderToTexture) return;\n    if (this.outputTexture && this.reuseOutputTexture) return;\n\n    const gl = this.rasterContext.getGlContext();\n    const outputTextureGl = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, outputTextureGl);\n\n    this.outputTexture = new Texture(\n      this.rasterContext,\n      outputTextureGl,\n      this.outputWidth,\n      this.outputHeight,\n      this.uint32 ? 32 : 8,\n    );\n\n    // Set the texture parameters\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n    // Define the the texture\n    if (this.uint32) {\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA32UI,\n        this.outputWidth,\n        this.outputHeight,\n        0,\n        gl.RGBA_INTEGER,\n        gl.UNSIGNED_INT,\n        null,\n      );\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.outputWidth, this.outputHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n\n    // Create a framebuffer object (FBO) only if not already created\n    this.framebuffer ??= gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n\n    // Attach the texture as a color attachment to the FBO\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTextureGl, 0);\n\n    // Check if the FBO is complete and properly set up\n    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n      console.error(\"Framebuffer is not complete.\", gl.checkFramebufferStatus(gl.FRAMEBUFFER));\n    }\n  }\n\n  private updateOutput() {\n    if (!this.outputNeedUpdate) return;\n\n    const gl = this.rasterContext.getGlContext();\n\n    if (this.renderToTexture && this.outputTexture && this.framebuffer) {\n      gl.bindTexture(gl.TEXTURE_2D, this.outputTexture.texture);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n    } else {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      gl.canvas.width = this.outputWidth * devicePixelRatio;\n      gl.canvas.height = this.outputHeight * devicePixelRatio;\n\n      if (!(gl.canvas instanceof OffscreenCanvas)) {\n        gl.canvas.style.width = `${this.outputWidth}px`;\n        gl.canvas.style.height = `${this.outputHeight}px`;\n      }\n\n      // Set the viewport size to match the canvas size\n      // gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    }\n\n    this.outputNeedUpdate = false;\n  }\n  /*\n  testVertexBuffer() {\n    if (!this.shaderProgram) return;\n\n    const gl = this.rasterContext.getGlContext();\n\n    // const bufferAttributeLocation = gl.getAttribLocation(this.shaderProgram, 'a_color');\n\n    // const vertexBuffer = gl.createBuffer();\n    // gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    // // Define the vertices of the rectangle\n    // const verticeData = [\n    //   1.0, 0.0, 0.0, 1.0,\n    //   0.0, 1.0, 0.0, 1.0,\n    //   0.0, 0.0, 1.0, 1.0,\n    //   1.0, 1.0, 1.0, 1.0,\n    // ];\n\n    // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticeData), gl.STATIC_DRAW);\n\n    // gl.enableVertexAttribArray(bufferAttributeLocation);\n    // gl.vertexAttribPointer(bufferAttributeLocation, 4, gl.FLOAT, false, 0, 0);\n\n    const colors = new Float32Array([\n      1.0,\n      0.0,\n      0.0,\n      1.0, // Red\n      0.0,\n      1.0,\n      0.0,\n      1.0, // Green\n      0.0,\n      0.0,\n      1.0,\n      1.0, // Blue\n      1.0,\n      1.0,\n      0.0,\n      1.0, // Yellow\n    ]);\n\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n\n    const colorAttributeLocation = gl.getAttribLocation(\n      this.shaderProgram,\n      \"aColor\"\n    );\n\n    gl.enableVertexAttribArray(colorAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);\n  }\n*/\n\n  /**\n   * Triggers the rendering of this node.\n   */\n  render() {\n    if (!this.shaderProgram) return;\n\n    const gl = this.rasterContext.getGlContext();\n\n    // make sure the program of this node is attached to the gl context\n    // (if .setShaderSource() is called on a different node before this\n    // node has rendered, this would otherwise cause mix match)\n    const currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);\n    if (currentProgram !== this.shaderProgram) {\n      gl.useProgram(this.shaderProgram);\n    }\n\n    this.initPlane();\n    this.initRenderToTextureLogic();\n    this.updateOutput();\n    this.initUniforms();\n\n    // this.testVertexBuffer();\n\n    // For some reasons clearing does not work if output is uint32\n    if (!this.uint32) {\n      gl.clearColor(this.clearColor[0], this.clearColor[1], this.clearColor[2], this.clearColor[3]);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  }\n\n  dispose() {\n    // TODO\n  }\n\n  /**\n   * Get the pixel data from GPU as a JS typed array. This requires this node to just rendered.\n   * Note: if another Node has been redered after this one, then this method will nor work or\n   * will retrieve the data from the last rendered node.\n   *\n   * If this node was instantiated with the option `uint32` being `true`, then the JS typed\n   * array will be a Uint32Array, unless the option `asFloat` is `true`. In this case, the\n   * returned array will be Float32Array.\n   *\n   * If this node was instanciated with `uint32` being `false` (which is the default), then\n   * the returned typed array is a Uint8Array\n   */\n  getPixelData(asFloat = false): Uint8Array | Uint32Array | Float32Array {\n    const gl = this.rasterContext.getGlContext();\n    const w = gl.canvas.width;\n    const h = gl.canvas.height;\n\n    if (this.uint32 && asFloat) {\n      const pixelData = new Uint32Array(w * h * 4);\n      gl.readPixels(0, 0, w, h, gl.RGBA_INTEGER, gl.UNSIGNED_INT, pixelData);\n      return new Float32Array(pixelData.buffer);\n    }\n\n    if (this.uint32 && !asFloat) {\n      const pixelData = new Uint32Array(w * h * 4);\n      gl.readPixels(0, 0, w, h, gl.RGBA_INTEGER, gl.UNSIGNED_INT, pixelData);\n      return pixelData;\n    }\n\n    const pixelData = new Uint8Array(w * h * 4);\n    gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);\n    return pixelData;\n  }\n\n  getImageData(): ImageData {\n    if (this.uint32) {\n      throw new Error(\"Uint32 image cannot be used to create an RGBA8 image.\");\n    }\n\n    const gl = this.rasterContext.getGlContext();\n    const w = gl.canvas.width;\n    const h = gl.canvas.height;\n    const imageData = new ImageData(w, h);\n    const pixelData = this.getPixelData();\n    imageData.data.set(pixelData);\n    return imageData;\n  }\n\n  async getImageBitmap(): Promise<ImageBitmap> {\n    const imageData = this.getImageData();\n    return createImageBitmap(imageData);\n  }\n\n  getNewOffscreenCanvas(): OffscreenCanvas {\n    const imageData = this.getImageData();\n    const canvas = new OffscreenCanvas(imageData.width, imageData.height);\n    const ctx = canvas.getContext(\"2d\") as OffscreenCanvasRenderingContext2D;\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  async getPNGImageBlob(): Promise<Blob | null> {\n    const canvas = this.getNewOffscreenCanvas();\n    const blob = await canvas.convertToBlob();\n    return blob;\n  }\n\n  async getPNGImageBuffer(): Promise<ArrayBuffer | null> {\n    if (this.uint32) {\n      console.warn(\"Cannot convert uint32 data into PNG.\");\n      return null;\n    }\n\n    const blob = await this.getPNGImageBlob();\n\n    if (!blob) {\n      console.warn(\"The PNG blob could not be created.\");\n      return null;\n    }\n\n    const pngBuffer = await blob.arrayBuffer();\n    return pngBuffer;\n  }\n\n  async getPNGImageObjectURL(): Promise<string | null> {\n    if (this.uint32) {\n      console.warn(\"Cannot convert uint32 data into PNG.\");\n      return null;\n    }\n\n    const blob = await this.getPNGImageBlob();\n\n    if (!blob) {\n      console.warn(\"The PNG blob could not be created.\");\n      return null;\n    }\n\n    return URL.createObjectURL(blob);\n  }\n\n  doesOutputNeedUpdate(): boolean {\n    return this.outputNeedUpdate;\n  }\n\n  /**\n   * Freeing element from GPU memory\n   */\n  free() {\n    const gl = this.rasterContext.getGlContext();\n\n    if (this.framebuffer) {\n      // Detach any attachment to avoid keeping references alive\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n      gl.deleteFramebuffer(this.framebuffer);\n      this.framebuffer = null;\n    }\n\n    if (this.outputTexture) {\n      this.outputTexture.free();\n    }\n\n    this.resetProgram();\n\n    if (this.positionBuffer) {\n      gl.deleteBuffer(this.positionBuffer);\n      this.positionBuffer = null;\n    }\n  }\n}\n","import type { ProcessingNode } from \"./ProcessingNode\";\nimport type { Texture } from \"./Texture\";\n\nexport type RasterContextOptions = {\n  /**\n   * Width of the canvas.\n   * Note that each ProcessingNode can have a width different from the RasterContext\n   * it is bound to.\n   */\n  width: number;\n\n  /**\n   * Height of the canvas.\n   * Note that each ProcessingNode can have a height different from the RasterContext\n   * it is bound to.\n   */\n  height: number;\n\n  /**\n   * If true, internally instantiates an OffscreenCanvas instead of an HTML Canvas Element.\n   * This is particularly handy for web workers.\n   * Default: false\n   */\n  offscreen?: boolean;\n};\n\nexport class RasterContext {\n  private readonly canvas: HTMLCanvasElement | OffscreenCanvas;\n  private readonly width: number;\n  private readonly height: number;\n  private readonly offscreen: boolean;\n  private readonly gl: WebGL2RenderingContext;\n  private readonly registeredTextures: Texture[] = [];\n  private readonly registeredProcessingNodes: ProcessingNode[] = [];\n\n  constructor(options: RasterContextOptions) {\n    this.offscreen = options.offscreen ?? false;\n    this.width = options.width;\n    this.height = options.height;\n\n    if (this.offscreen) {\n      this.canvas = new OffscreenCanvas(this.width, this.height);\n    } else {\n      this.canvas = document.createElement(\"canvas\");\n      this.canvas.width = this.width;\n      this.canvas.height = this.width;\n    }\n\n    const gl = this.canvas.getContext(\"webgl2\", {\n      alpha: true,\n      premultipliedAlpha: false,\n    }) as WebGL2RenderingContext;\n\n    if (!gl) {\n      throw new Error(\"This device is not compatible with WebGL2\");\n    }\n\n    this.gl = gl;\n  }\n\n  getCanvas(): HTMLCanvasElement | OffscreenCanvas {\n    return this.canvas;\n  }\n\n  getGlContext(): WebGL2RenderingContext {\n    return this.gl;\n  }\n\n  getSize(): { width: number; height: number } {\n    return {\n      width: this.width,\n      height: this.height,\n    };\n  }\n\n  isOffscreen(): boolean {\n    return this.offscreen;\n  }\n\n  registerTexture(tex: Texture) {\n    this.registeredTextures.push(tex);\n  }\n\n  registerProcessingNode(node: ProcessingNode) {\n    this.registeredProcessingNodes.push(node);\n  }\n\n  /**\n   * Free textures and processing nodes from GPU memory\n   */\n  free() {\n    for (const node of this.registeredProcessingNodes) {\n      node.free();\n    }\n\n    for (const tex of this.registeredTextures) {\n      tex.free();\n    }\n  }\n}\n"],"mappings":"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"}